# 知识点拾遗
## Java
### Collections
#### HashMap
key-value结构，允许null值，线程不安全，非有序非同步，底层数组+链表+红黑树(JDK1.8)，负载因子loadFactor(0.75)，阈值(threshold)=容器容量(capacity)*负载因子(load factor)

通过扰动函数得到hash值，再通过hash&(length-1)代替取模的方式进行元素定位

底层**数组**，哈希表元素`Node<k, v> table`数据结构包含
1. 哈希值`final int hash`
2. 数据键`final K key`
3. 数据值`V value`
4. 元素节点`Node<K, V> next`：单链表结构用于解决hash冲突，数据量大于8时转为红黑树

哈希冲突
(当前元素hash值)%(hash表长度得到存储位置)，解决Hash冲突的方法有：开放定址法，再散列法，链地址法，公共溢出区法，HashMap使用的是**链地址法**，优化方面：Java7需要做4次16位右位移异或混合，Java8中做了简化，只需要做一次16位右位移异或混合即可

只有length的长度是2的n次方时，h&(length-1)才等价于h%length，且碰撞的几率较小

负载因子
表示哈希表空间的使用程度(哈希表空间的利用率)

常用操作底层实现原理  
put  
![HashMap_Put_Value](pic/Hashmap_put.png)

get  
![HashMap_Get_Value](pic/Hashmap_get.png)

remove  
![HashMap_Remove_Value](pic/Hashmap_remove.png)

replace  
![HashMap_Replace_Value](pic/Hashmap_replace.png)

多线程操作HashMap存在的问题：
1. 数据不一致/数据污染：多线程操作导致已修改数据被旧数据重新覆盖
2. 自动扩容机制在多线程条件下构成死循环

使用不可变对象作为Key，如String，Integer等

#### HashTable
线程安全每个操作方法前都有synchronized修饰，但不推荐使用，读写全局加锁效率低下，使用CurrentHashMap代替
Key，value均不可为null，初始容量为11，扩容方式为2倍再加1

#### ArrayList
非线程安全，在向一个ArrayList中添加大量元素前，可以使用ensureCapacity方法来增加ArrayList的容量。添加n个元素需要的时间为O(n)。结构型修改时必须在外部做同步，使用Collections.synchronizedList方法来包装

#### LinkedList
双向链表，同样需要Collections.synchronizedList方法来包装同步，插入及删除操作的时间复杂度为O(1)，可以动态改变大小，链表主要的缺点是：由于其链式存储的特性，链表不具备良好的空间局部性，也就是说，链表是一种缓存不友好的数据结构。

#### HashSet
HashSet非线程安全，是一个value=PERSENT的HashMap，并且没有get方法（无序不重复的散列集，get无意义）

### Java内存模型(Java Memory Model, JMM)
通过定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量的底层细节，屏蔽各种硬件和操作系统的内存访问差异，以实现在各个平台内存访问都能达到一致性。是在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。
1. 工作内存数据一致性
2. 指令重排优化，分为编译期重排序和运行期重排序

线程对变量的所有操作(读取，赋值)都必须在**工作内存**中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要**通过主内存**来完成，**实现**各个线程提供**共享变量的可见性**。

内存交互的基本操作(原子性)
1. lock (锁定) 作用于**主内存**的变量，它把一个变量标识为一条线程独占的状态。
2. unlock (解锁) 作用于**主内存**的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
3. read (读取) 作用于**主内存**的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。
4. load (载入) 作用于**工作内存**的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。
5. use (使用) 作用于**工作内存**的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时就会执行这个操作。
6. assign (赋值) 作用于**工作内存**的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
7. store (存储) 作用于**工作内存**的变量，它把工作内存中一个变量的值传送到主内存中，以便随后 write 操作使用。
8. write (写入) 作用于**主内存**的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。

内存操作的3个特性：为了保证数据一致性
原子性(Atomicity)
可见性(Visibility)
有序性(Ordering)

Java底层通过**内存屏障**来保证**有序性**和**可见性**，常通过volatile，synchronized和Unsafe类使用

**lock、unlock成对出现，read后即为load，store后即为write不可缺失，工作内存中的共享变量必须从主内存诞生，工作内存未更新不允许无原因更新主内存**

LoadLoad屏障：load操作对后续可见
StoreStore屏障：store操作对后续可见
LoadStore屏障：后续store前load已经结束
StoreLoad屏障：开销最大(冲刷写缓冲器，清空无效队列)，大多数处理器实现中为万能屏障，兼具上述三种屏障功能

volatile变量内存屏障插入策略(因此推荐使用场景为：一次(单一线程)写入，到处(多线程)读取，如标志位更新，观察者模型变量值发布)
StoreStore屏障 -> 变量写 -> StoreLoad屏障
LoadLoad屏障 -> 变量读 -> LoadStore屏障

final变量再初始化完成后会立刻会写到主内存，且后期不能修改，因此保证了多线程下的可见性

synchronized读数据只能在主内存操作，写数据操作离开同步区时就刷新回主内存了

### 垃圾回收
p68
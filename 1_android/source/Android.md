# 移动端梳理
[目录]
## Android平台架构
Android软件堆栈
![Android软件堆栈](https://developer.android.google.cn/guide/platform/images/android-stack_2x.png)

系统启动流程
Boot ROM -> Boot Loader -> Kernel -> init -> Demons
                                          -> Zygote -> Dalvik VM -> System Services -> Managers
                                          -> sRuntime             -> Service Manager

应用启动流程
```

```


### Applications-应用程序
#### 系统应用
AndroidManifest文件中声明`android:sharedUserId="android.uid.system"`，可使用系统API，如使用PackageManager进行静默安装/卸载

#### 第三方应用/用户应用


### ApplicationFramework-Java API框架

#### 视图系统
丰富、可扩展的视图系统，可用以**构建应用的UI**，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器


#### 资源管理器
资源管理器，用于访问**非代码资源**，例如本地化的字符串、图形和布局文件

#### 通知管理器
通知管理器，可让所有应用在状态栏中显示自定义提醒，**管理通知栏自定义提醒**

#### Activity管理器
Activity管理器，用于**管理应用的生命周期，提供常见的导航返回栈**

#### 内容提供程序
内容提供程序，可让应用**跨进程访问或共享数据**（例如“联系人”应用）


### AndroidRuntime-运行时
不同于Java虚拟机，Android将class字节码文件优化为dex文件，使用内存更少。
#### Dalvik

#### ART
Android5.0(API=21)
预先 (AOT) 和即时 (JIT) 编译  
优化的垃圾回收 (GC)  
在 Android 9（API 级别 28）及更高版本的系统中，支持将应用软件包中的 Dalvik Executable 格式 (DEX) 文件转换为更紧凑的机器代码。  
更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置观察点以监控特定字段


### 原生C/C++库
提供核心Android系统组件和服务，支持C/C++代码开发的应用


### HAL硬件抽象层
剥离硬件差异对上层应用产生的影响，硬件抽象层 (HAL) 提供标准接口，HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一组接口，比如WIFI/蓝牙模块，当框架API请求访问设备硬件时，Android系统将为该硬件加载相应的库模块。


### Linux内核
依靠 Linux 内核来执行底层功能，例如内核安全，线程和低层内存管理。
#### 系统和内核安全
操作系统级别的这些安全功能旨在确保即使是原生代码也要受应用沙盒的限制。无论相应代码是自带应用行为导致的结果，还是利用应用漏洞导致的结果，系统都能防止违规应用危害其他应用、Android系统或设备本身。
##### Linux安全
##### 应用沙盒
##### 系统分区和安全模式
##### 文件系统权限
##### 安全增强型 Linux
##### 启动时验证
##### 加密
##### Root权限
##### 用户安全功能
##### 设备管理

#### 应用安全
AndroidManifest.xml中必须指定需要使用哪些权限，Android6.0及以上版本更是应用了运行时权限模式。
##### Android权限模型
访问受保护的API：
摄像头功能
位置数据（GPS）
蓝牙功能
电话功能
短信/彩信功能
网络/数据连接

##### 进程间通信（重要）
进程可以使用 UNIX 类型的任何传统机制进行通信。如文件系统，本地套接字或信号
Android独有的IPC机制：
Binder：一种基于功能的轻量型远程过程调用机制，使用自定义Linux驱动程序实现
服务：提供能够使用 Binder 直接访问的接口。
Intent：简单的消息对象，表示想要执行某项操作的“意图”。
ContentProvider：用于访问设备上的数据

##### 费用敏感API
##### SIM卡访问
第三方应用无法对 SIM 卡进行底层访问。操作系统负责处理与 SIM 卡之间的所有通信，包括访问 SIM 卡内存中的个人信息（通讯录）。应用也无法访问 AT 命令，因为这些命令完全由无线接口层 (RIL) 进行管理。RIL 不会为这些命令提供任何高层 API。
##### 个人信息
通讯录和日历
##### 敏感数据输入设备
摄像头、麦克风或 GPS
##### 设备元数据
操作系统日志、浏览器历史记录、电话号码以及硬件/网络标识信息。
##### 证书授权机构
仅信任系统证书授权机构（CA）授权的证书文件，并且Android7.0及更高版本不再允许设备制造商对其进行修改。
##### 应用签名
程序会拒绝没有获得签名就尝试安装的应用，系统签名，第三方签名，自签名
##### 应用验证
Android 4.2 及更高版本均支持应用验证
##### 数字版权管理
Android 平台提供了一个可扩展的 DRM 框架，主要用在Media DRM Server
![Android 平台上的数字版权管理架构](https://source.android.google.cn/devices/images/ape_fwk_drm_2.png)

#### 实现安全
Lint代码静态检查  
模糊测试，边界测试  
##### 隔离Root进程
常见Root进程：vold、inetd、zygote、tf_daemon、ueventd 和 init  
尽可能通过 IPC 访问 Root 代码，将 Root 功能缩减成可通过 Binder 访问的小型服务，并将这个具有签名权限的服务提供给网络流量处理权限很小或没有此类权限的应用。  
Root 进程不得通过网络套接字进行监听。
Root 进程不得为应用提供通用运行时  
##### 隔离系统应用
应尽可能减少设备上作为系统代码运行的必要代码的数量。尽可能通过 Android 进程自身的 UID 使用此类进程，而非重复使用系统 UID。
应尽可能将系统代码与不可信数据隔离开来，并且系统代码应尽可能仅向其他可信进程提供 IPC。
系统进程不得通过网络套接字进行监听。
##### 隔离进程
Root 进程不得访问各个应用数据文件夹内的数据，使用已记录的 Android 调试方法时除外。
Root 进程不得访问应用内存，使用已记录的 Android 调试方法时除外。
设备上不得有任何会访问其他应用/进程的数据或内存的应用。
##### 保护 SUID 文件
SUID 进程不得提供可被用来规避 Android 安全模型的 shell 或后门程序。
必须确保任何用户都无法对 SUID 程序执行写入操作。
SUID 程序不应为全局可读或全局可执行程序。创建一个组，限定只有该组的成员能够访问相应的 SUID 二进制文件，并将应该能够执行相应 SUID 程序的所有应用放入该组中。
SUID 程序经常会被用户用作获取设备 Root 权限的来源。为了降低这种风险，应确保 shell 用户无法执行 SUID 程序。
##### 保护监听套接字
设备上不应存在监听端口

##### 记录数据
记录数据的做法会增加数据遭泄露的风险并降低系统性能。
1. 应用或系统服务不应记录第三方应用提供的可能包含敏感信息的数据。
2. 应用不得在正常操作过程中记录任何个人身份信息 (PII)。
##### 限制对目录的访问
全局可写目录可能会引入安全漏洞，并且可能会使应用能够重命名可信文件、替换文件或进行基于符号链接的攻击（攻击者可能会利用指向某个文件的符号链接诱使可信程序执行不应执行的操作）。可写目录还可能会导致卸载应用后无法适当清除与相应应用关联的所有文件。  
系统用户或 Root 用户创建的目录不应为全局可写目录。CTS 测试能够测试已知目录
##### 保护配置文件
许多驱动程序和服务都依赖于存储在 /system/etc 和 /data 等目录中的配置文件和数据文件。
##### 存储原生代码库
特权设备制造商进程使用的所有代码都必须位于 /vendor 或 /system 中；这些文件系统会在设备启动时以只读模式装载。最佳做法：系统使用的库或手机上安装的其他权限非常高的应用使用的库也应位于这些文件系统中。这有助于防止出现可让攻击者用来控制特权进程执行的代码的安全漏洞。
##### 限制对设备驱动程序的访问
应该只有可信代码能够直接访问驱动程序。首选架构要尽可能提供一个单一用途守护进程来代理向驱动程序发出的调用，并仅限该守护进程访问驱动程序。最佳做法：驱动程序设备节点不应为全局可读或全局可写节点。CTS 测试能够检查是否存在全局可读或全局可写驱动程序的已知实例
##### 停用ADB
##### 解锁引导加载程序
lock bootloader




### 参考资料
https://developer.android.google.cn/guide/platform
## iOS
## 匿名内部类

## Java匿名内部类使用限制
1. **匿名内部类没有名字**：但编译器会指定一个**外部类 + $n**组成匿名内部类的名字，通过反射也可以正常获取
2. **匿名内部类只能继承一个父类或实现一个接口**：由于匿名类由父类或接口直接派生，且Java语法不支持`|`或类型，所以不支持，即使Java10的类型推导var也不可以。
   1. 定义在方法体内的local class，可实现继承父类的同时又实现接口，但其已经不是匿名内部类了
   2. Kotlin语法支持这样做
3. 父类是非静态类型，则实例化时需要在构造方法中传入**父类实例和使用的外部类实例**来初始化
4. 接口实现相当于静态实现，所以是以**接口创建的内部类不包含内部类的实例引用**，但还是在构造方法中传入了使用的外部类的实例引用
5. 内部类中**使用外部类的对象需要用final修饰**（Java8会自行添加），内部类中使用的外部类是对其对象的快照，修改后会造成内外对象不一致问题

## 与Lambda表达式的联系和区别
Java Lambda 表达式的一个重要用法是简化某些匿名内部类的写法，因此它可以部分取代匿名内部类的作用。

### 使用条件
单一方法类型（SAM）：**单一接口方法** 时才能使用

### 相同点
1. Lambda 表达式的代码块与匿名内部类的方法体是相同的
2. Lambda 表达式内访问局部变量与匿名内部类一样有 final 修饰，不允许重新赋值
3. Lambda 表达式创建的对象与匿名内部类生成的对象一样，都可以直接调用从接口中**继承**的抽象方法

### 不同点
1. 匿名内部类可以为**抽象类甚至普通类**或**任意接口**创建实例；但 Lambda 表达式只能为函数式接口创建实例
2. 匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法；但 Lambda 表达式的代码块不允许调用接口中**定义**的默认方法

## 接口（interface）中的默认方法（default）
Java8引入，特点如下：
1. 实现类会继承接口中的default方法
2. 如果一个类同时实现接口A和B，接口A和B中有相同的default方法，这时，该类必须重写接口中的default方法
3. 如果子类继承父类，父类中有b方法，该子类同时实现的接口中也有b方法（被default修饰），那么子类会继承父类的b方法而不是继承接口中的b方法

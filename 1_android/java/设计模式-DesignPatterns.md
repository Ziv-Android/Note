# 设计模式
## 概览
建造型，5种
工厂方法，抽象工厂，单例，建造者，原型

结构型，7种
适配器，装饰器，代理，外观，桥接，组合，享元

行为型，11种
策略，模板方法，观察者，迭代器，责任链，命令，备忘录，状态，访问者，中介者，解释器

## 模式之间的对比
### 简单工厂、工厂方法、抽象工厂、builder建造者模式之间的区别
简单工厂：一个工厂创建不同类型的对象
工厂方法：一个具体的工厂负责一个具体的对象类型
抽象工厂：一个具体的工厂创建一系列相关的对象
Builder模式：将对象的构建和表示分离，更专注于对象的构建过程

### 静态代理与动态代理的区别和使用场景
主要区别：
1. 创建代理类的时机不同，程序运行前代理类已经存在的即为静态代理，否则就是动态代理
2. 由于运行时无需生成代理类，所以静态代理的运行效率比动态代理更高
静态代理使用场景：
类数目有限，有较高性能要求的场景下，如四大组件和AIDL与AMS进行跨进程通信时
动态代理使用场景：
需要对多个功能相同的类进行代理，如Retrofit中使用动态代理`retrofit.create()`来创建网络请求服务类，极大的提高了扩展性和可维护性

### 装饰模式、代理模式和桥接模式有哪些区别
装饰模式：对装饰对象的增强
代理模式：对代理对象的保护
桥接模式：减少子类的数量和复杂度

### 外观模式和中介模式的区别
外观模式：对外提供统一接口，便于使用
中介模式：避免多个相互协作对象的耦合


### 策略模式和状态模式的区别
策略模式：在于策略算法的替换
状态模式：通过状态来改变行为


### 适配器模式、装饰者模式与外观模式的异同



## Android中常见的模式使用
builder模式：AlertDialog与Notification的初始化创建
抽象工厂：通过BaseActivity构建主题切换功能的抽象类或接口
责任链模式：OkHttp的Interceptor拦截器，ViewGroup的事件传递
观察者模式：RxJava的observer和observable，ListView/RecyclerView的Adapter.notifyDataSetChanged()
代理模式：通过AIDL与AMS通信
适配器模式：
外观模式：Context/ContextImpl


![图片加载测试]](https://shanhs.oss-cn-shenzhen.aliyuncs.com/newboss/2018-05-30/56e10ded-4700-4809-9ef8-270d296bbfc5.png)

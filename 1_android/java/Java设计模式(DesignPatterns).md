# 设计模式
## 概览
建造型，5种
工厂方法，抽象工厂，单例，建造者，原型

结构型，7种
适配器，装饰器，代理，外观，桥接，组合，享元

行为型，11种
策略，模板方法，观察者，迭代器，责任链，命令，备忘录，状态，访问者，中介者，解释器

## 模式之间的对比
### 简单工厂、工厂方法、抽象工厂、builder建造者模式之间的区别
简单工厂：一个工厂创建不同类型的对象
工厂方法：一个具体的工厂负责一个具体的对象类型
抽象工厂：一个具体的工厂创建一系列相关的对象
Builder模式：将对象的构建和表示分离，更专注于对象的构建过程

### 静态代理与动态代理的区别和使用场景
主要区别：
1. 创建代理类的时机不同，程序运行前代理类已经存在的即为静态代理，否则就是动态代理
2. 由于运行时无需生成代理类，所以静态代理的运行效率比动态代理更高
静态代理使用场景：
类数目有限，有较高性能要求的场景下，如四大组件和AIDL与AMS进行跨进程通信时
动态代理使用场景：
需要对多个功能相同的类进行代理，如Retrofit中使用动态代理`retrofit.create()`来创建网络请求服务类，极大的提高了扩展性和可维护性

### 装饰模式、代理模式和桥接模式有哪些区别
装饰模式：对装饰对象的增强，优化繁复的继承关系
代理模式：通过代理类，控制原有对象的引用，对代理对象的保护
桥接模式：某个类族有多个变化维度，导致子类类型激增，桥接模式可隔离变化，最后组合即可。大大减少子类的数量和复杂度

### 外观模式和中介模式的区别
外观模式：对外提供统一接口，便于使用
中介模式：避免多个相互协作对象的耦合，松耦合应对变化


### 策略模式和状态模式的区别
策略模式：在于策略算法的替换
状态模式：通过状态来改变行为


### 适配器模式、代理模式与外观模式的异同
外观模式针对系统级的整合，多个接口按顺序统一操作调用
代理模式针对对象进行控制访问
适配器模式调用转换已有接口，实现原本不兼容的接口协同工作


## Android中常见的模式使用
builder模式：AlertDialog与Notification的初始化创建
优点：良好的封装性，减少内部细节暴漏；独立建造者，更容易扩展。
缺点：产生多余的Builder对象和Director对象，消耗内存。

抽象工厂：通过BaseActivity构建主题切换功能的抽象类或接口


责任链模式：OkHttp的Interceptor拦截器，ViewGroup的事件传递
观察者模式：RxJava的observer和observable，ListView/RecyclerView的Adapter.notifyDataSetChanged()
代理模式：通过AIDL与AMS通信
适配器模式：
外观模式：Context/ContextImpl

## 设计模式优缺点
### 建造型
1. 工厂方法模式  
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展  

   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
2. 抽象工厂模式
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
3. 单例模式
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
4. 建造者（builder）模式：将一个复杂对象的构建和表示分离。
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
5. 原型模式
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存

### 结构型
1. 适配器模式
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
2. 装饰器模式
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
3. 代理模式
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
4. 外观
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
5. 桥接
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
6. 组合
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
7. 享元
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存

### 行为型
1. 策略
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
2. 模板方法
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
3. 观察者
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
4. 迭代器
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
5. 责任链
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
6. 命令
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
7. 备忘录
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
8. 状态
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
9.  访问者
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
10. 中介者
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
11. 解释器
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存
12. 建造者（builder）模式：将一个复杂对象的构建和表示分离。
   优点：
   1. 良好的封装，避免暴漏内部组成细节
   2. 建造者独立，更容易扩展
   缺点：
   1. 会产生多余的Builder对象和Director对象，消耗内存


## 代码坏味道
代码重复，方法过长，复杂功能类，数据泥团，冗余类，过多说明注释

![图片加载测试]](https://shanhs.oss-cn-shenzhen.aliyuncs.com/newboss/2018-05-30/56e10ded-4700-4809-9ef8-270d296bbfc5.png)
